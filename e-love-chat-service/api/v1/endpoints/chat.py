# WARNING: This code was generated by ChatGPT. The author is not responsible for its functionality.

"""
WebSocket Integration for E-Love Chat Service

This module integrates the MessagesService and ConversationsService with FastAPI's WebSocket
functionality to enable real-time chat capabilities. It allows clients to connect via WebSockets,
join conversations, send messages, and receive messages from other participants in real time.

Dependencies:
- fastapi: For creating the WebSocket endpoints and managing the application.
- fastapi.websockets: For handling WebSocket connections.
- sqlalchemy.ext.asyncio: For asynchronous database interactions.
- typing: For type hinting.
- uuid: For handling unique identifiers.
- core.services.conversations_service: The ConversationsService class for managing conversations.
- core.services.messages_service: The MessagesService class for managing messages.
- core.db.models.chat.conversations: The Conversations model.
- core.db.models.chat.messages: The Messages model.
- asyncio: For asynchronous operations and synchronization.
- collections: For managing active connections.

Classes:
- ConnectionManager: Manages active WebSocket connections and broadcasts messages to participants.
- ChatWebSocket: FastAPI APIRouter handling WebSocket connections for chat functionality.

Functions:
- connect: Handles new WebSocket connections and registers them with the ConnectionManager.
- disconnect: Handles disconnections and unregisters them from the ConnectionManager.
- send_personal_message: Sends a personal message to a specific WebSocket connection.
- broadcast: Broadcasts a message to all participants in a conversation.

Usage:
This module is intended to be included in the main FastAPI application. It provides WebSocket endpoints
that clients can connect to for real-time chat interactions. Ensure that the application is properly
configured with the necessary services and database connections before integrating this module.
"""

from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends, HTTPException
from fastapi.responses import HTMLResponse
from sqlalchemy.ext.asyncio import AsyncSession
from uuid import UUID
from typing import Dict, List
import asyncio
import logging

from core.services.conversations.conversations_service import ConversationsService
from core.services.message.message_service import MessagesService
from core.db.models.chat.conversations import Conversations
from core.db.models.chat.message import Message
from configuration.database import get_db_session

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

router = APIRouter()


@router.post("/conversations")
async def create_chat_conversation(data: dict, db: AsyncSession = Depends(get_db_session)):
    user_first_id = data.get("user_first_id")
    user_second_id = data.get("user_second_id")

    # Вызываем сервис
    service = ConversationsService(db)
    conversation = await service.create_conversation(
        {"user_first_id": user_first_id, "user_second_id": user_second_id}
    )

    return {
        "id": str(conversation.id),
        "user_first_id": str(conversation.user_first_id),
        "user_second_id": str(conversation.user_second_id),
    }


@router.websocket("/{conversation_id}")
async def chat_endpoint(
    websocket: WebSocket, conversation_id: UUID, db: AsyncSession = Depends(get_db_session)
):
    await websocket.accept()
    conversations_service = ConversationsService(db)
    messages_service = MessagesService(db)

    # Проверим, что conversation существует
    await conversations_service.get_conversation_by_id(conversation_id)

    try:
        while True:
            data = await websocket.receive_json()
            action = data.get("action")

            # if action == "authenticate":
            #     # Можно добавить проверку токена, если надо
            #     pass

            if action == "send_message":
                payload = data["data"]
                # sender_id = payload["sender_id"]
                recipient_id = payload["recipient_id"]
                sender_id = "00cebe39-9159-500a-a4d3-efb9932ec33a"
                # recipient_id = "014de6ad-1d30-5bfb-bad4-5bf4d7ff1f52"
                content = payload["content"]

                new_message = await messages_service.create_message(
                    {"conversation_id": conversation_id, "sender_id": sender_id, "content": content}
                )

                # Отправляем обратно уведомление о сохранении
                await websocket.send_json(
                    {
                        "action": "message_saved",
                        "data": {
                            "sender_id": sender_id,
                            "recipient_id": recipient_id,
                            "content": content,
                        },
                    }
                )
    except WebSocketDisconnect:
        pass
