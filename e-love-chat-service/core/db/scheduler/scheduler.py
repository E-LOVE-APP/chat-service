# WARNING: This code was generated by ChatGPT. I'm not responsible for its functionality, but it works. I tried to add very informative docstrings but IDK if it will help you...

"""
Scheduler Module for E-Love Chat Service

This module is responsible for managing scheduled tasks within the E-Love Chat Service application.
Specifically, it handles the periodic removal of conversations that have been soft-deleted for over 30 days.
The scheduler operates asynchronously to ensure it does not block the main application processes.

Dependencies:
- asyncio: Python's standard library for writing concurrent code using the async/await syntax.
- datetime: Module for manipulating dates and times.
- logging: Provides a flexible framework for emitting log messages from Python programs.
- signal: Provides mechanisms to use signal handlers in Python.
- APScheduler (Advanced Python Scheduler): A library for scheduling jobs in Python applications.
- SQLAlchemy: A SQL toolkit and Object-Relational Mapping (ORM) library for Python.

Functions:
- remove_old_deleted_conversations: Asynchronously deletes conversations marked as deleted for over 30 days.
- start_scheduler: Configures and starts the APScheduler with the defined job.
- shutdown: Gracefully shuts down the scheduler and stops the event loop.
- main: The main asynchronous function that initializes the scheduler and handles shutdown signals.

Usage:
This script is intended to be run as a standalone module within a Docker container.
Ensure that the Docker environment is correctly set up with all necessary dependencies and configurations.
"""

import asyncio
import logging
import signal
from datetime import datetime, timedelta

from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.interval import IntervalTrigger
from sqlalchemy.future import select

from configuration.database import get_db_session
from core.db.models.chat.conversations import Conversations

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


# TODO: potentially, deletions by packets or chunks of bytes will fit better here.
async def remove_old_deleted_conversations():
    """
    Asynchronously removes conversations that have been marked as deleted for more than 30 days.

    This function performs the following steps:
    1. Establishes an asynchronous database session using the provided dependency.
    2. Calculates the cutoff date, which is 30 days prior to the current UTC time.
    3. Executes a SELECT query to retrieve all conversations where:
       - `is_deleted` is True, indicating a soft deletion.
       - `deleted_at` is earlier than the calculated cutoff date.
    4. Iterates over the retrieved conversations and deletes each one from the database.
    5. Commits the transaction to persist the deletions.
    6. Logs the number of conversations deleted or indicates if there are none to delete.

    Error Handling:
    - If an exception occurs during the database operations, the transaction is rolled back.
    - The error is logged for debugging and monitoring purposes.

    Notes:
    - This function is intended to be scheduled to run at regular intervals (e.g., daily) to maintain
      the database by removing outdated soft-deleted conversations.
    """
    async for db in get_db_session():
        thirty_days_ago = datetime.utcnow() - timedelta(days=30)
        try:

            result = await db.execute(
                select(Conversations).where(
                    Conversations.is_deleted == True, Conversations.deleted_at < thirty_days_ago
                )
            )

            old_conversations = result.scalars().all()

            if old_conversations:
                for conversation in old_conversations:
                    await db.delete(conversation)
                await db.commit()
                logger.info(f"Deleted {len(old_conversations)} old deleted conversations.")
            else:
                logger.info("No old deleted conversations to delete.")

        except Exception as e:
            await db.rollback()
            logger.error(f"Error removing old deleted conversations: {e}")


def start_scheduler(scheduler: AsyncIOScheduler):
    """
    Configures and starts the APScheduler with the defined job.

    Parameters:
    - scheduler (AsyncIOScheduler): An instance of APScheduler's AsyncIOScheduler.

    This function performs the following actions:
    1. Adds a job to the scheduler that invokes `remove_old_deleted_conversations` every day.
    2. Configures the job with a unique identifier and name for easy management.
    3. Starts the scheduler to begin executing scheduled jobs.
    4. Logs the successful start of the scheduler.

    Notes:
    - The job is set to replace any existing job with the same ID to prevent duplicates.
    - The IntervalTrigger is configured to trigger the job once every day.
    """
    scheduler.add_job(
        remove_old_deleted_conversations,
        trigger=IntervalTrigger(days=1),  # Schedule to run daily
        id="remove_old_deleted_conversations",
        name="Remove conversations soft-deleted over 30 days ago",
        replace_existing=True,
    )
    scheduler.start()
    logger.info("Scheduler started for removing old deleted conversations.")


async def shutdown(scheduler: AsyncIOScheduler):
    """
    Gracefully shuts down the scheduler and stops the event loop.

    Parameters:
    - scheduler (AsyncIOScheduler): The APScheduler instance to be shut down.

    This function performs the following actions:
    1. Shuts down the scheduler, ensuring all jobs are properly terminated.
    2. Logs the successful shutdown of the scheduler.
    3. Stops the asyncio event loop to allow the program to exit cleanly.

    Notes:
    - This function is intended to be called when the application receives termination signals
      such as SIGINT (interrupt) or SIGTERM (terminate).
    """
    scheduler.shutdown()
    logger.info("Scheduler shutdown successfully.")
    asyncio.get_event_loop().stop()


async def main():
    """
    The main asynchronous function that initializes and manages the scheduler.

    This function performs the following actions:
    1. Creates an instance of AsyncIOScheduler from APScheduler.
    2. Configures and starts the scheduler by invoking `start_scheduler`.
    3. Sets up signal handlers to gracefully shut down the scheduler upon receiving
       termination signals (SIGINT and SIGTERM).
    4. Initiates an indefinite wait to keep the scheduler running.

    Signal Handling:
    - Registers handlers for SIGINT and SIGTERM to ensure that the scheduler shuts down
      gracefully when the application is interrupted or terminated.
    - Uses asyncio tasks to handle the shutdown process asynchronously.

    Notes:
    - The use of `asyncio.Event().wait()` creates an indefinite wait, effectively keeping the
      program running to allow the scheduler to operate.
    - Proper signal handling ensures that resources are cleaned up and the application exits
      without leaving dangling processes or corrupted states.
    """
    # Initialize the APScheduler instance.
    scheduler = AsyncIOScheduler()
    # Configure and start the scheduler with the defined jobs.
    start_scheduler(scheduler)

    # Retrieve the current running event loop.
    loop = asyncio.get_running_loop()
    # Define the signals to listen for termination.
    for sig in (signal.SIGINT, signal.SIGTERM):
        loop.add_signal_handler(sig, lambda: asyncio.create_task(shutdown(scheduler)))

    await asyncio.Event().wait()


if __name__ == "__main__":
    """
    Entry point for the Scheduler module.

    This block checks if the script is being run directly and not being imported as a module.
    If executed directly, it runs the `main` asynchronous function within the asyncio event loop.

    Error Handling:
    - Catches KeyboardInterrupt and SystemExit exceptions to log when the scheduler is stopped.
    - Ensures that the application exits gracefully without leaving incomplete processes.
    """
    try:
        # Run the main asynchronous function, which manages the scheduler and event loop.
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        # Log that the scheduler has been stopped due to an interrupt or termination signal.
        logger.info("Scheduler stopped.")
